1. `get_free_page()` 返回的是线性地址，内核已经开启分页，无论如何都是线性地址。它对应的物理页在 `head.S` 里就已经映射到内核线性地址空间了。
2. 为什么 `get_free_page()` 要从后往前捋？

- 将线性和物理地址错开，随机化，增加安全性？拿到线性地址，猜不到物理地址。

ylx：没有脱离用户进程的独立的内核

3. 进程的时间片包含内核里运行的时间吗？（思考）

我：算时间，进程的时间片 `counter` 在每次时钟中断时 -1，内核跑的时候，时钟也在计时。

如果在内核态里时间片跑完了，`do_timer` 里也不会发生调度，而是根据 `cpl == 0` 直接返回，继续内核的执行路径。

而后，在内核路径执行完后，退出前再检查时间片是否用完，如果用完，则发生调度。

> Linux 中系统调用是陷阱门，通过 `int 0x80` 陷入时，CPU 不清除 eflags 的中断使能；而中断门则不同，调用中断门时，CPU 会将 eflags 的中断使能清除，防止嵌套中断。

4. 所有进程的 `eflags.iopl` 都是 `0`，表明无法在 `3` 态执行 `cli`，`sti` 等指令。最初是在 `INIT_TASK` 里初始化的。

如何保证移植范围内滴水不漏地进行访问控制？（思考）
