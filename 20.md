### `add_request()`

传入 `&blk_dev[3]` 和刚做好的 `request` 项指针。

> 思考：这里的 `cli()` 在防什么竞争？
> 中断来源于硬件，因此此处防止硬件中断的竞争。标准：中断到来是否引起内核操作的混乱？

- `add_request()`
    - 关闭中断，主要防止之前没完成的硬盘操作现在中断
    - 缓冲区 `dirt` 清 0，`BADNESS` 中 `dirt` 权更大
    - 此时 `dev->current_request` 为空（全局变量初始化），进入分支

    ```c
    if (!(tmp = dev->current_request)) {
		dev->current_request = req;
		sti();
		(dev->request_fn)();
		return;
	}
    ```

    通过函数指针 `dev->request_fn` 调用 `do_hd_request()`
- `do_hd_request()`：硬盘的驱动程序，`hd_out` 是关键，和驱动挂钩子

- `hd_out`
  - 此时 `do_hd` 被挂为 `read_intr`，这就是接下来硬盘中断的处理函数。该函数是根据请求的不同而动态变化的。
  - 而后通过 `outb` 宏向硬盘发命令（port IO 模式/ PIO）

  > 硬盘的工作流程
  > 1. CPU 通过端口向硬盘发命令
  > 2. 硬盘将数据读入自身的存储器上
  > 3. 读取结束后向 CPU 发中断请求
  > 4. CPU 将硬盘存储器上的数据搬运到内存缓冲区

  - 发送完命令后，整体返回到 `bread()`

## 返回到 `bread()`

- `wait_on_buffer` 等待缓冲区解锁（`make_request` 中加锁），意味着数据已经从硬盘中读回缓冲区。

    > `sleep_on` 执行后，进程 1 的状态为 `TASK_UNINTERRUPTIBLE`，进程 0 的状态为 `TASK_INTERRUPTIBLE`，进程 0 和进程 1 都挂起了。

    `schedule()` 函数中找 `next` 的部分中：
    ```c
    while (1) {
		c = -1;
		next = 0;
		i = NR_TASKS;
		p = &task[NR_TASKS];
		while (--i) {
			if (!*--p)
				continue;
			if ((*p)->state == TASK_RUNNING && (*p)->counter > c)
				c = (*p)->counter, next = i;
		}
		if (c) break;
        ...
	}
    ```
    由于所有 task 的状态均不为 `TASK_RUNNING`，`c` 的值仍然为 1，`next` 为 0，从而下面的 `switch_to()` 调度到了 `task[0]`，即 0 号进程。

    > 1. 上面代码的含义是：如果所有非 0 号进程都被挂起了，则调度到进程 0。
    > 2. 进程 0 被调度回来时，执行的代码就是 ljmp 的下一条。

    进程 0 回到用户态 `for(;;) pause();` 自旋，此时在等待读硬盘的中断。

## 硬盘中断 `hd_interrupt`

关键代码：
```s
1:	xorl %edx,%edx
	xchgl do_hd,%edx
	testl %edx,%edx
	jne 1f
	movl $unexpected_hd_interrupt,%edx
1:	outb %al,$0x20
	call *%edx		# "interesting" way of handling intr.
```

跳转到之前挂的钩子上，通过 `do_hd`，此时的钩子值为 `read_intr`。注意，`xchgl` 指令同时也将 `do_hd` 清零了。

> 使用钩子的原因是：硬盘读写的技术路线极度相似，通过钩子区分读和写操作的不同。
