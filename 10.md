此时运行的是进程 0 的条件：（`sched_init` 中 `lldt(0);ltr(0);`）
- ldtr 指向进程 0 的 ldt 段
  - cs 指向进程 0 的代码段
  - ss 指向进程 0 的数据段
- tr 指向进程 0 的 tss 段

15. 进程 0：`fork()` 一个子进程，子进程运行 `init()`，自身陷入自旋

系统调用：通过 `int 0x80`
```c
#define _syscall0(type,name) \
  type name(void) \
{ \
long __res; \
__asm__ volatile ("int $0x80" \
	: "=a" (__res) \
	: "0" (__NR_##name)); \
if (__res >= 0) \
	return (type) __res; \
errno = -__res; \
return -1; \
}
```

`int 0x80` 发生时，CPU 自动从 tss 段读取内核栈段和栈指针，然后将原来的 ss、esp、eflags、cs、eip 压入内核栈中

系统调用的入口为 `system_call.s` 的 `system_call`

- 检查系统调用号是否越界：

```s
system_call:
	cmpl $nr_system_calls-1,%eax
	ja bad_sys_call
```
ylx：不同的系统调用按“授权”分开，用户跑不出“确定性”集合之外的“授权”

- 准备系统调用参数：

```s
    push %ds
	push %es
	push %fs
	pushl %edx
	pushl %ecx		# push %ebx,%ecx,%edx as parameters
	pushl %ebx		# to the system call
```

- 设置 ds 为内核数据段，设置 fs 为？？？

```s
    movl $0x10,%edx		# set up ds,es to kernel space
	mov %dx,%ds
	mov %dx,%es
	movl $0x17,%edx		# fs points to local data space
	mov %dx,%fs
```

- 调用系统调用表里的系统调用函数：

```s
	call *sys_call_table(,%eax,4)
```

- 进入 `sys_fork`：

    ```s
    .align 2
    sys_fork:
        call find_empty_process
        testl %eax,%eax
        js 1f
        push %gs
        pushl %esi
        pushl %edi
        pushl %ebp
        pushl %eax
        call copy_process
        addl $20,%esp
    1:	ret
    ```

  - `find_empty_process`：
    1. `last_pid` 累加器，来一个进程加一下
    2. 返回第一个 `task` 数组项为空的下标
  - `copy_process`：
    1. 传参：epi，cs，eflags，esp，ss 在 `int 0x80` 时入栈，ebx，ecx，edx，fs，es，ds 在刚进入系统调用时入栈，none 对应的是 `call sys_call_table` 时的返回地址

    ```c
    int copy_process(int nr,long ebp,long edi,long esi,long gs,long none,
            long ebx,long ecx,long edx,
            long fs,long es,long ds,
            long eip,long cs,long eflags,long esp,long ss)
    ```
    2. `get_free_page` 分配一页，指向 `task_union`
 