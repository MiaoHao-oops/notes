## `sleep_on` 和 `wake_up`

```c
void sleep_on(struct task_struct **p)
{
	struct task_struct *tmp;

	if (!p)
		return;
	if (current == &(init_task.task))
		panic("task[0] trying to sleep");
	tmp = *p;
	*p = current;
	current->state = TASK_UNINTERRUPTIBLE;
	schedule();
	if (tmp)
		tmp->state=0;
    // *p = tmp;
}

void wake_up(struct task_struct **p)
{
    if (p && *p) {
        (**p).state=0;
        *p=NULL;    // ylx：应该改为 *p=tmp; 进程应该一个一个唤醒，而不是一个一个唤醒
    }
}
```

缓冲块进程等待队列：
- 缓冲块先进入 `hashtable`，然后同步数据
通过 `tmp` 保存在进程的内核栈上

> 形成一个队列：唤醒的中断只有一次，因此需要串起来“全部”唤醒

## `bread` 后的文件系统

### 关于 uptodate

如果进程拿到了一个 uptodate 为 0 的缓冲块，则进程是不能直接读这个缓冲块的，因为此时缓冲块中的内容可能是垃圾数据。需要从硬盘中把数据更新到缓冲块中，读完后将 uptodate 置为 1，进程才能从缓冲块中读取数据。

### 文件系统

> 为什么 bread 中 drive 要乘 5？
> 因为目前系统中每块硬盘最多支持 4 个逻辑盘，分区的起始扇区信息存在结构 `struct hd_struct` 中，0 为物理盘，1～4 为逻辑盘

> 一切外设均为文件

根文件系统（bootsect.s 中定义 `ROOT_DEV` 为 `0x306`）：只被别的文件系统挂载，其他文件系统均挂载在根文件系统的目录上。

当前内核最多允许打开 32 个文件（`inode_table` 有 32 项），8 个 `superblock` 意味着最多支持 8 个逻辑盘。

```c
struct m_inode inode_table[NR_INODE]={{0,},};

struct super_block super_block[NR_SUPER];

struct super_block {
	unsigned short s_ninodes;
	unsigned short s_nzones;
	unsigned short s_imap_blocks;
	unsigned short s_zmap_blocks;
	unsigned short s_firstdatazone;
	unsigned short s_log_zone_size;
	unsigned long s_max_size;
	unsigned short s_magic;
/* These are only in memory */
	struct buffer_head * s_imap[8];
	struct buffer_head * s_zmap[8];
	unsigned short s_dev;
	struct m_inode * s_isup;    // superblock 的 inode
	struct m_inode * s_imount;  // 挂载点的 inode
	unsigned long s_time;
	struct task_struct * s_wait;
	unsigned char s_lock;
	unsigned char s_rd_only;
	unsigned char s_dirt;
};
```
